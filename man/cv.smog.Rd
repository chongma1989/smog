% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utility.R
\name{cv.smog}
\alias{cv.smog}
\title{Cross-valiation for smog}
\usage{
cv.smog(x, y, g, v, lambda, hierarchy, family = "gaussian", nfolds = 10,
  parallel = FALSE, ncores = NULL, ...)
}
\arguments{
\item{x}{a model matrix, or a data frame of dimensions n by p, 
in which the columns represents the predictor variables.}

\item{y}{response variable, corresponds to the family description. 
When family is ``gaussian'' or ``binomial'', \code{y} ought to
be a numeric vector of observations of length n; when family 
is ``coxph'', \code{y} represents the survival objects, containing the 
survival time and the censoring status. See \code{\link[survival]{Surv}}.}

\item{g}{a vector of group labels for the predictor variables.}

\item{v}{a vector of binary values, represents whether or not the 
predictor variables are penalized. Note that 1 indicates 
penalization and 0 for not penalization.}

\item{lambda}{a numeric vector of three penalty parameters corresponding to L2 norm,
squared L2 norm, and L1 norm, respectively.}

\item{hierarchy}{a factor value in levels 0, 1, 2, which represent different
hierarchical structure within groups, respectively. 
When \code{hierarchy=0}, \eqn{\lambda_2} and \eqn{\lambda_3} are 
forced to be zeroes; when \code{hierarchy=1}, \eqn{\lambda_2} is 
forced to be zero; when \code{hierarchy=2}, there is no constraint 
on \eqn{\lambda}'s. See more explainations under ``Details''.}

\item{family}{a description of the distribution family for the response 
variable variable. For continuous response variable,
family is ``gaussian''; for multinomial or binary response
variable, family is ``binomial''; for survival response
variable, family is ``coxph'', respectively.}

\item{nfolds}{number of folds. One fold of the observations in the data are used
as the testing, and the remaining are fitted for model training. 
Default is 10.}

\item{parallel}{Whether or not process the \code{nfolds} cross-validations in
parallel. If \code{TRUE}, use \code{\link[foreach]{foreach}} to do each 
cross-validation in parallel. Default is \code{FALSE}.}

\item{ncores}{number of cpu's for parallel computing. See
\code{\link[parallel]{makeCluster}} and \code{\link[doParallel]{registerDoParallel}}.
Default is \code{NULL}.}

\item{...}{other arguments that can be supplied to \code{smog}.}
}
\value{
the average of Akaike's Information Criterions (AICs) from
        the \code{nfolds} cross-validations. Note that AIC is 
        -2log-likelihood+2\eqn{p_l}, where \eqn{p_l} is the number 
        of non-zero predictor variables.
}
\description{
\code{cv.smog} conducts the \code{nfolds} cross-validations for the whole data,
where one fold of the observations are used for model-testing, and the remaining 
data are used for model-building. It allows the \code{nfolds} to be processed
in parallel, in order to speed up the cross-validation. However, it can only do 
the cross-validations for one user-specified \code{lambda}, because \code{lambda} 
is a three-dimensional vector, the optimal search for \code{lambda} is quite 
computationally expensive. The \code{cv.smog} outputs the Akaike's Information Criterion
(AIC) for each testing.
}
\details{
The function runs \code{smog} \code{nfolds} times. Evenly split the whole
         data into \code{nfolds}, and one fold of the observations are used as 
         the testing data, and the remaining are used for model training. After
         calculating the AIC for each fold of testing data, return the average of the 
         AICs. Note that this method does NOT search for the optimal penalty parameters 
         \code{lambda}, and a specific \code{lambda} should be supplied.
}
\examples{
#require(plotly)

# generate design matrix x
set.seed(2018)
n=50;p=1000
s=10
x=matrix(0,n,1+2*p)
x[,1]=sample(c(0,1),n,replace = TRUE)
x[,seq(2,1+2*p,2)]=matrix(rnorm(n*p),n,p)
x[,seq(3,1+2*p,2)]=x[,seq(2,1+2*p,2)]*x[,1]

g=c(p+1,rep(1:p,rep(2,p)))  # groups 
v=c(0,rep(1,2*p))           # penalization status

# generate beta
beta=c(rnorm(13,0,2),rep(0,ncol(x)-13))
beta[c(2,4,7,9)]=0

# generate y
data=x\%*\%beta
noise=rnorm(n)
snr=as.numeric(sqrt(var(data)/(s*var(noise))))
y=data+snr*noise

l1=l2=10^(-seq(1,3,0.2))
cvmod=matrix(0,length(l1),length(l2))
\dontrun{
for(i in 1:length(l1)){
  for(j in i:length(l2)){
    cvmod[i,j] = cv.smog(x,y,g,v,lambda=c(l1[i],0,l2[j]),
                         hierarchy=1,family="gassian",nfolds=10,scale=TRUE)
  }
}

plot_ly(x=l1,y=l2,z=t(cvmod),type="contour",
        contours=list(showlabels=TRUE))\%>\%
        colorbar(title="aic")\%>\%
        layout(xaxis=list(title="lambda1"),
               yaxis=list(title="lambda2"))\%>\%
        config(mathjax='cdn')

}

}
\seealso{
\code{\link{smog.default}}, \code{\link{smog.formula}}, \code{\link{predict.smog}}, \code{\link{plot.smog}}.
}
\author{
Chong Ma, \email{chong.ma@yale.edu}.
}
